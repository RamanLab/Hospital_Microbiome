---
title: Diversity Plots and Network Analysis
author: Pratyay Sengupta, Vijay Kapse
date: February 14, 2024
output: R_analysis
---

## **Introduction**

This document presents an analysis of diversity and network properties using R packages for microbiome data. It includes loading necessary packages, data pre-processing, diversity analysis, and network construction.

**Loading Packages**

```{r load-packages, echo=TRUE}
# Loading necessary packages
library(dplyr)
library(ggforce)
library(ggplot2)
library(ggpubr)
library(gplots)
library(igraph)
library(LaplacesDemon)
library(limma)
library(microbiome)
library(NetCoMi)
library(phyloseq)
library(sjPlot)
library(vegan)
library(dendextend)
```

**Loading the necessary data for creating phyloseq objects**

```{r}
# Setting the working directory
phyloseq_path <- "/mnt/Local_Disk_1/2_Hospital_Microbiome/Data/Output_data/phyloseq_source/"
network_path <- "/mnt/Local_Disk_1/2_Hospital_Microbiome/Data/Output_data/network_files/"
figure_path <- "/mnt/Local_Disk_1/2_Hospital_Microbiome/Data/Figures/"

# Loading and processing the data
environments <- c("all", "Hospital", "MetaSUB", "Office")

# Looping over three environments
for (env in environments) {
  
  # Constructing file paths
  otu_file <- paste(phyloseq_path, env, "_filtered_data.csv", sep="")
  metadata_file <- paste(phyloseq_path, env, "_filtered_metadata.csv", 
                sep="")
  taxa_file <- paste(phyloseq_path, env, "_filtered_taxa.csv", sep="")
  
  # Reading OTU data
  otu_data <- read.table(otu_file, sep = ',', header=TRUE, check.names=FALSE)
  otu_data <- data.frame(otu_data[,-1], row.names = otu_data[,1], check.names=FALSE)
  otu_data <- otu_table(otu_data, taxa_are_rows = TRUE)
  
  # Reading metadata
  meta_data <- read.table(metadata_file, sep = ',', header=TRUE)
  meta_data <- data.frame(meta_data[,-1], row.names = meta_data[,1])
  meta_data <- sample_data(meta_data)
  
  # Reading taxonomy data
  taxa_data <- read.table(taxa_file, sep = ',', header=TRUE)
  taxa_data <- data.frame(taxa_data[,-1], row.names = taxa_data[,1])
  taxa_data <- as.matrix(taxa_data)
  taxa_data <- tax_table(taxa_data)
  
  # Creating phyloseq object
  physeq <- phyloseq(otu_data, taxa_data, meta_data) 
  assign(paste0("physeq_", env), physeq)
}
```

## **Diversity randomisation**

```{r}
# Setting seed for reproducibility
set.seed(123)

# Extracting metadata
metadata <- sample_data(physeq_all)
metadata <- cbind(Sample = rownames(metadata), metadata)
rownames(metadata) <- 1:nrow(metadata)

# Find the environment with the lowest number of samples
env_counts <- table(metadata$Environment)
min_env <- names(which.min(env_counts))
min_n <- min(env_counts)  # Smallest number of samples

# Store results
alpha_results <- data.frame()

# Run 100 iterations of random sampling and alpha diversity calculations
for (i in 1:100) {
  sampled_meta <- metadata %>%
    group_by(Environment) %>%
    filter(Environment == min_env | row_number() %in% sample(1:n(), min_n)) %>%
    ungroup()
  
  sampled_physeq <- prune_samples(sample_names(physeq_all) %in% sampled_meta$Sample, physeq_all)
  
  # Calculate alpha diversity
  alpha_div <- microbiome::alpha(sampled_physeq, index = "shannon")
  alpha_div$Environment <- sampled_meta$Environment  # Add environment column
  alpha_div$Iteration <- i  # Track iteration
  
  # Store results
  alpha_results <- rbind(alpha_results, alpha_div)
}

# Plot alpha diversity
p.shannon.random <- ggplot(alpha_results, aes(x = Environment, y = diversity_shannon, color = Environment)) +
  geom_boxplot(alpha = 0.5, outlier.shape = NA) +
  geom_jitter(width = 0.2, alpha = 0.5) +
  theme_classic() +
  labs(x = "Environment", y = "Shannon Diversity") +
  stat_compare_means(method = "anova", label.y = max(alpha_results$diversity_shannon) + 0.2) +  # Overall test
  stat_compare_means(comparisons = list(c("Env1", "Env2"), c("Env1", "Env3"), c("Env2", "Env3")), method = "t.test")  # Pairwise tests

p.shannon.random

# Saving the plot
ggsave(paste0(figure_path, "Supplementary_2.svg"), plot = p.shannon.random, 
       width = 4, height = 5)

```

## **Diversity Analysis**

**Alpha Diversity**

```{r}
# Calculating alpha diversity
alpha_div <- microbiome::alpha(physeq_all, index = "all")

# Plotting alpha diversity
p.shannon <- boxplot_alpha(physeq_all, index = "shannon", x_var = "Environment",
                           element.alpha = 0.5) +
  theme_classic() + labs(x="Environment", y="Shannon diversity")
p.shannon
```

**Alpha Diversity: Significance Testing**

```{r}
# Testing differences
dif <- meta(physeq_all)
dif$diversity <- alpha_div$diversity_shannon
spl <- split(dif$diversity, dif$Environment)

p_matrix <- matrix(NA, nrow = length(spl), ncol = length(spl))

for (i in 1:length(spl)) {
  for (j in 1:length(spl)) {
    if (i != j) {
      ks_result <- ks.test(spl[[i]], spl[[j]])$p.value
      ks_result <- p.adjust(ks_result, method = "BH")
      p_matrix[i, j] <- ks_result
    } else {
      p_matrix[i, j] <- 1  # Diagonal elements (self-comparisons)
    }
  }
}

rownames(p_matrix) <- colnames(p_matrix) <- names(spl)

# Saving the plot
ggsave(paste0(figure_path, "Fig_2B.svg"), plot = p.shannon, 
       width = 4, height = 5)
```

**Beta Diversity**

```{r}
# Calculating beta diversity
beta_div <- distance(physeq_all, method = "bray")

# Performing NMDS
set.seed(123)
nmds_result <- ordinate(physeq_all, method = "NMDS", distance = "bray")
```

```{r}
# Plotting beta diversity
p.beta <- plot_ordination(physeq_all, nmds_result, color = "Environment") + 
  geom_point(aes(color = Environment), size = 3) +
  stat_ellipse(aes(x = NMDS1, y = NMDS2, group = Environment),
               geom = "polygon", alpha = 0.1, 
               linetype = "dashed", color = "black") +
  theme_minimal()

p.beta

ggsave(paste0(figure_path, "Fig_2C.svg"), plot = p.beta, 
              width = 6, height = 5)
```

```{r}
# Getting the environmental data from the phyloseq object
environment_data <- data.frame(sample_data(physeq_all))

# Extracting the NMDS data from the NMDS object
nmds_data <- data.frame(nmds_result$points)
nmds_data <- cbind(nmds_data, environment_data)

# Creating box plots for NMDS axes 
p.box1 <- ggplot(nmds_data, aes(x = MDS1, y = 1, fill = Environment)) +
  geom_boxplot() +
  labs(x = "", y = "NMDS1") +
  coord_cartesian(xlim = c(-3.5, 5.5)) +
  theme_minimal() +
  theme(legend.position = "none")

p.box2 <- ggplot(nmds_data, aes(x = 1, y = MDS2, fill = Environment)) +
  geom_boxplot() +
  labs(x = "NMDS2", y = "") +
  coord_cartesian(ylim = c(-4.5, 4.5)) +
  theme_minimal() +
  theme(legend.position = "none")

```

```{r}
# Combine scatter plot and marginal box plots
 combined_plot <- ggarrange(
   p.box1,
   NULL,
   p.beta + theme(legend.position = "none"), 
   p.box2,
   ncol = 2,
   nrow = 2,
   widths = c(10, 3),  
   heights = c(3, 10)  
 )

ggsave(paste0(figure_path, "Fig_2C_v2.svg"), plot = combined_plot, 
              width = 6, height = 5)

combined_plot
```

**Beta Diversity: Significance Testing**

```{r}
# Testing differences
adonis_result <- adonis2(beta_div ~ Environment + Surface.Material + Location + Site, 
                         data = as(sample_data(physeq_all), "data.frame"),
                         permutations = 999, method = "bray", by = "terms")
```

**Diversity for Randomised Community**

```{r}
set.seed(123)

# Subsampling rndomly
sample_data_df <- as.data.frame(sample_data(physeq_all))  
hospital_samples <- rownames(sample_data_df[sample_data_df$Environment == "Hospital", ])
metasub_samples <- rownames(sample_data_df[sample_data_df$Environment == "MetaSUB", ])
office_samples <- rownames(sample_data_df[sample_data_df$Environment == "Office", ])  

# Randomly select 30 samples from hospital and metasub
hospital_selected <- sample(hospital_samples, 30)
metasub_selected <- sample(metasub_samples, 30)

# Combine selected samples
selected_samples <- c(office_samples, hospital_selected, metasub_selected)

# Prune phyloseq object to selected samples
physeq_subset <- prune_samples(selected_samples, physeq_all)

# Verify the sample counts
table(sample_data(physeq_subset)$Environment)

# Print the subsetted phyloseq object
physeq_subset

# Calculating alpha diversity
alpha_div_sub <- microbiome::alpha(physeq_subset, index = "all")

# Plotting alpha diversity
p.shannon_sub <- boxplot_alpha(physeq_subset, index = "shannon", x_var = "Environment",
                           element.alpha = 0.5) +
  theme_classic() + labs(x="Environment", y="Shannon diversity")
p.shannon_sub


```

```{r}
# Testing differences
dif <- meta(physeq_subset)
dif$diversity <- alpha_div_sub$diversity_shannon
spl <- split(dif$diversity, dif$Environment)

p_matrix <- matrix(NA, nrow = length(spl), ncol = length(spl))

for (i in 1:length(spl)) {
  for (j in 1:length(spl)) {
    if (i != j) {
      ks_result <- ks.test(spl[[i]], spl[[j]])$p.value
      ks_result <- p.adjust(ks_result, method = "BH")
      p_matrix[i, j] <- ks_result
    } else {
      p_matrix[i, j] <- 1  # Diagonal elements (self-comparisons)
    }
  }
}

rownames(p_matrix) <- colnames(p_matrix) <- names(spl)
```

```{r}
# Calculating beta diversity
beta_div_sub <- distance(physeq_subset, method = "bray")

# Performing NMDS
set.seed(123)
nmds_result_sub <- ordinate(physeq_subset, method = "NMDS", distance = "bray")

p.beta_sub <- plot_ordination(physeq_subset, nmds_result_sub, color = "Environment") + 
  geom_point(aes(color = Environment), size = 3) +
  stat_ellipse(aes(x = NMDS1, y = NMDS2, group = Environment),
               geom = "polygon", alpha = 0.1, 
               linetype = "dashed", color = "black") +
  theme_minimal()

p.beta_sub
```

**Class Level Plot**

```{r}
# Class-level plot
pseq.class.rel <-aggregate_rare(physeq_all, level = "class", 
                                detection = 0.001, prevalence = 0.1)


p.compositions <- plot_composition(pseq.class.rel,
                      average_by = "Environment") + 
  guides(fill = guide_legend(ncol = 1)) + 
  labs(x = "Study", 
       y = "Relative abundance")
#title = "Relative abundance data", 
#subtitle = "Subtitle",
#caption = "Caption text.") 
p.compositions <- p.compositions + scale_fill_brewer("Abundant Class", 
                      palette = "Paired") + theme_minimal()

p.compositions

ggsave(paste0(figure_path, "Fig_2D.svg"), plot = p.compositions, 
       width = 6, height = 5)
```

## **Network Construction**

```{r}
# Network construction
environments <- environments[environments != "all"]

for (env in environments) {
  print(env)
  physeq_env <- get(paste0("physeq_", env))
  
  # Network construction
  micro_net <- netConstruct(physeq_env,
                            measure = "gcoda",
                            normMethod = "TSS",
                            zeroMethod = "multRepl",
                            dissFunc = "signed",
                            sparsMethod = "bootstrap",
                            alpha = 0.05,
                            adjust = "adaptBH",
                            nboot = 1000L,
                            assoBoot = NULL,
                            logFile = "log.txt",
                            cores = 8,
                            knnMutual = FALSE,
                            seed = 123,
                            verbose = 3)
  
  # Network properties
  net_prop <- netAnalyze(micro_net, clustMethod = "cluster_fast_greedy",
                            weightDeg = FALSE,
                            centrLCC = TRUE,
                            hubPar = c("degree", "eigenvector", 
                                       "betweeness", "closeness"),
                            gcmHeat = FALSE)
  
  assign(paste0("network_", env), micro_net)
  assign(paste0("properties_", env), net_prop)
  
  # Saving edges details (class-level analysis)
  edge_details <- dplyr::select(micro_net$edgelist1, v1, v2)
  edge_details$Weight <- micro_net$edgelist1$adja
  
  write.csv(edge_details, file = paste0(network_path, env,"_edges.tsv"), 
            row.names = FALSE)
  
  # Saving edges details (gephi)
  edges <- dplyr::select(micro_net$edgelist1, v1, v2)
  edges$Source <- as.numeric(factor(edges$v1))
  edges$Target <- as.numeric(factor(edges$v2))
  edges$Type <- "Undirected"
  edges$Weight <- micro_net$edgelist1$adja
  
  # Saving nodes details (gephi)
  nodes <- unique(edges[,c('v1','Source')])
  colnames(nodes) <- c("Label", "Id")

  # Add category with clusters (can be used as node colors in Gephi)
  nodes$Category <- net_prop$clustering$clust1[nodes$Label]

  edges <- dplyr::select(edges, Source, Target, Type, Weight)

  
  write.csv(nodes, file = paste0(network_path, "gephi_inputs/", 
                                 env,"_nodes.csv"), row.names = FALSE)
  write.csv(edges, file = paste0(network_path, "gephi_inputs/", 
                                 env,"_edges.csv"), row.names = FALSE)
}
```

**Network Visualization**

```{r}

# Defining color palettes
color_palettes <- list(
  c("coral4", "deeppink", "khaki3", "green4", "darkgreen"),
  c("blue", "orange", "purple", "red", "yellow"),
  c("cyan", "magenta", "plum", "salmon", "darkviolet")
  #c("navy", "turquoise", "plum", "brown", "olive"),
  #c("darkred", "darkblue", "darkgreen", "darkorange", "darkviolet")
)


for (i in seq_along(environments)){
  env <- environments[i]
  
  prop_plot <- get(paste0("properties_", env))
  
  color_pal <- color_palettes[[i]]
  
  svg(paste0(figure_path, paste0(env, "_network.svg"), 
             width = 12, height = 10))
  
  net_plot <- plot(prop_plot, 
          layout = "spring",
          repulsion = 0.65,
          labels = FALSE,
          
          # Nodes:
          rmSingles = TRUE,
          nodeColor = "cluster", 
          nodeSize = "degree",
          nodeShape1 = "circle",
          borderWidth = 1,
          borderCol = "black",
          nodeSizeSpread = 3,
          cexNodes = 2,
          colorVec = color_pal,
          
          # Edges:
          edgeWidth = 0.5,
          
          # Edge interactions
          negDiffCol = TRUE,
          posCol = "darkblue",
          negCol = "darkorange3",
          edgeTranspLow = 30,
          edgeTranspHigh = 60)
  
  dev.off()
}
```

**Extracting required properties and details from the network**

```{r}
# Consolidation of basic network properties

all_nodes <- length(properties_Office$clustering$clust1)
nodes <- length(properties_Office$clusteringLCC$clust1)

edges <- nrow(network_Office$edgelist1)
neg <- sum(network_Office$edgelist1$asso < 0)
pos <- sum(network_Office$edgelist1$asso > 0)

# properties of LCC
cluster <- as.numeric(max(properties_MetaSUB$clusteringLCC$clust1))
modularity <- as.numeric(properties_Office$globalPropsLCC$modularity1)
clustering_coeff <- as.numeric(properties_Office$globalPropsLCC$clustCoef1)
density <- as.numeric(properties_Office$globalPropsLCC$density1)

deg <- properties_Office$centralities$degree1
non_zero_deg <- deg[deg != 0]
length(non_zero_deg)
deg_avg <- mean(non_zero_deg)
deg_std <- sd(non_zero_deg)

close <- properties_Office$centralities$close1
non_zero_close <- close[close != 0]
length(non_zero_close)
close_avg <- mean(non_zero_close)
close_std <- sd(non_zero_close)

between <- properties_Office$centralities$between1
non_zero_between <- between[between != 0]
length(non_zero_between)
between_avg <- mean(non_zero_between)
between_std <- sd(non_zero_between)

eigenv <- properties_Office$centralities$eigenv1
non_zero_eigenv <- eigenv[eigenv != 0]
length(non_zero_eigenv)
eigenv_avg <- mean(non_zero_eigenv)
eigenv_std <- sd(non_zero_eigenv)

```

```{r}
# Create an empty data frame to store the results

# Iterate over environments
for (env in environments) {
  # Get properties and network for the current environment
  prop_net <- get(paste0("properties_", env))
  net_data <- get(paste0("network_", env))
  
  # Get corresponding variables for the current environment
  all_nodes <- length(prop_net$clustering$clust1)
  nodes <- length(prop_net$clusteringLCC$clust1)
  edges <- nrow(get(paste0("network_", env))$edgelist1)
  neg <- sum(net_data$edgelist1$asso < 0)
  pos <- sum(net_data$edgelist1$asso > 0)
  cluster <- as.numeric(max(prop_net$clusteringLCC$clust1))
  modularity <- as.numeric(prop_net$globalPropsLCC$modularity1)
  clustering_coeff <- as.numeric(prop_net$globalPropsLCC$clustCoef1)
  density <- as.numeric(prop_net$globalPropsLCC$density1)
  
  
  deg <- prop_net$centralities$degree1
  non_zero_deg <- deg[deg != 0]
  deg_avg <- mean(non_zero_deg)
  deg_std <- sd(non_zero_deg)
  close <- prop_net$centralities$close1
  non_zero_close <- close[close != 0]
  close_avg <- mean(non_zero_close)
  close_std <- sd(non_zero_close)
  between <- prop_net$centralities$between1
  non_zero_between <- between[between != 0]
  between_avg <- mean(non_zero_between)
  between_std <- sd(non_zero_between)
  eigenv <- prop_net$centralities$eigenv1
  non_zero_eigenv <- eigenv[eigenv != 0]
  eigenv_avg <- mean(non_zero_eigenv)
  eigenv_std <- sd(non_zero_eigenv)
  
  
  # Store the variables in a data frame
  result <- data.frame(
    all_nodes = all_nodes,
    nodes = nodes,
    edges = edges,
    neg = neg,
    pos = pos,
    cluster = cluster,
    modularity = modularity,
    clustering_coeff = clustering_coeff,
    density = density,
    deg_avg = deg_avg,
    deg_std = deg_std,
    close_avg = close_avg,
    close_std = close_std,
    between_avg = between_avg,
    between_std = between_std,
    eigenv_avg = eigenv_avg,
    eigenv_std = eigenv_std
  )
  

}

```

**Plot**

```{r}

features <- list()
node_count <- list()
edge_count <- list()

for (env in environments){
  physeq_object <- get(paste0("physeq_", env))
  feat <- nrow(otu_table(physeq_object))
  features <- c(features, feat)
  
  prop_object <- get(paste0("properties_", env))
  node <- length(prop_object$clusteringLCC$clust1)
  node_count <- c(node_count, node)
  
  net_data <- get(paste0("network_", env))
  edge <- nrow(net_data$edgelist1)
  edge_count <- c(edge_count, edge)
}

#svg(paste0(figure_path, "feature_plots.svg", width = 10, height = 6))

# Create a new window with two plots side by side
par(mfrow = c(1, 2))

# Plot list1 vs list2
plot(features, node_count, xlab = "Features", 
     ylab = "Node Count(LCC)", main = "Features vs Node", pch = 16)

# Plot list1 vs list3
plot(features, edge_count, xlab = "Features", 
     ylab = "Edge Count", main = "Features vs Edge", pch = 16)

#dev.off()
```

**Clusters information**

```{r}
# Initialize list to store cluster-wise names
names_cluster_wise <- list()

# Iterate over environments
for (i in seq_along(environments)){
  env <- environments[i]
  
  # Extract cluster information
  prop_plot <- get(paste0("properties_", env))
  cluster_info <- as.data.frame(prop_plot$clusteringLCC$clust1)
  
  # Assign column names
  names(cluster_info) <- paste0(env, "_LCC_clusters")
  
  # Write cluster info to CSV
  write.csv(cluster_info, file = paste0(network_path, 
                  "clusters/", env, "_LCC_clusters.csv"))
  
  # Get number of clusters
  nclust <- as.numeric(max(cluster_info))
  
  # Loop over clusters
  for (j in 1:nclust) {
    # Subset cluster info for current cluster
    names <- cluster_info[cluster_info[[1]] == j, , drop = FALSE]
    
    # Store row names in names_cluster_wise list
    names_cluster_wise[[paste0(as.character(env), 
                  "_", j)]] <- rownames(names)
  }
}

# Function to compute Jaccard similarity between two sets
jaccard_similarity <- function(set1, set2) {
  intersection <- length(intersect(set1, set2))
  union <- length(union(set1, set2))
  return(1 - (intersection / union))
}

# Function to create all-vs-all similarity matrix with key names
create_similarity_matrix <- function(list_of_lists) {
  n <- length(list_of_lists)
  keys <- names(list_of_lists)
  similarity_matrix <- matrix(0, n, n, dimnames = list(keys, keys))
  
  # Calculate Jaccard similarity for all pairs of lists
  for (i in 1:(n - 1)) {
    for (j in (i + 1):n) {
      similarity <- jaccard_similarity(list_of_lists[[i]], 
                  list_of_lists[[j]])
      similarity_matrix[i, j] <- similarity
      similarity_matrix[j, i] <- similarity
    }
  }
  
  # Round similarity values to two decimal places
  similarity_matrix <- round(similarity_matrix, 2)
  
  # Set upper triangular part to NA
  similarity_matrix[upper.tri(similarity_matrix)] <- NA
  
  return(similarity_matrix)
}

# Compute all-vs-all similarity matrix
similarity_matrix <- create_similarity_matrix(names_cluster_wise)

# Write similarity matrix to CSV
write.csv(similarity_matrix, file = paste0(network_path, "clusters/", "distance_matrix.csv"))

```

```{r}
hc <- hclust(as.dist(similarity_matrix))

svg(file = paste0(figure_path, "Figure_4D.svg"), 
             width = 6, height = 5)

# Plot the dendrogram
plot(hc, main = "Hierarchical Clustering Dendrogram")

dev.off()
```

**Collecting hub information**

```{r}
# Consolidation of hub information
centralities <- c("degree1", "between1", "close1", "eigenv1")

# Storing the results in a list for plotting
centrality_list <- list()

# Looping through environments
for (env in environments) {
  print(env)
  hubs <- data.frame()
  for (cent in centralities) {
    net_hub <- get(paste0("properties_", env))
    hub_info <-  head(sort(net_hub$centralities[[cent]], 
                           decreasing = TRUE), 10)
    hub_df <- data.frame(cent = names(hub_info), value = hub_info)
    
    # Modification of the dataframe
    col_name <- c("Organism", as.character(cent))
    names(hub_df) <- col_name
    row.names(hub_df) <- NULL
    
    # Appending the result to the list
    centrality_list[[paste0(env, "_", cent)]] <- hub_df$Organism
    
    if (nrow(hubs) == 0) {
      hubs <- hub_df
    }
    else {
      hubs <- cbind(hubs, hub_df)
    }
  }
  
  # Saving the dataframe
  assign(paste0("hubs_", env), hubs)
  
  write.csv(hubs, file = paste0(network_path, "hub_files/", 
                                env,"_hubs.tsv"), 
            row.names = FALSE)
}
```
